#
# directory_of
#    Returns pathname of a file or directory simply by stripping of
#    the last name.
# Argument
#    file: Full path name of file or directory
#

proc directory_of {file} {
    set i [string length $file]
    while {$i>0&&"[string index $file $i]"!="/"} {incr i -1}
    incr i -1
    return [string range $file 0 $i]
}

#
# file_of
#    Returns filename.
# Arguments
#    file: Full pathname of file
#

proc file_of {file} {
    set i [string length $file]
    while {$i>0&&"[string index $file $i]"!="/"} {incr i -1}
    incr i
    return [string range $file $i end]
}

#
# get_env
#    Substitutes for environment variables in a string and returns result
# Argument
#    s: Any string containing environment variables
#

proc get_env {s} {
    global env
    if ![regexp {\$} $s] {return $s}
    
    regsub -all {\$[A-Z0-9_]+} $s "\$env(&)" s
    regsub -all {\(\$} $s {(} s
    eval "set s $s"
    return $s
}

# unique_jobfile
#    Returns unique name of a file to be used as a temporary file.
# Method
#    A unique process id is generated by spawning a shell

proc unique_jobfile {} {
    return /tmp/ghuijobedit.[exec /bin/sh -c "echo $$"]
}
    
# evalEmbeddedCommands evalEmbeddedCommand2
#   These two procedures enable functions to be embedded in the text
#   part of window components. eg 
#     .text "Max value [get_variable_value MAX]" L
#   The value of the UI variable MAX will be output to the panel and
#   to the jobsheet output 
# Method
#   $ and quotes need to be protected from evaluation

proc evalEmbeddedCommands {a} {
    regsub -all \" $a \\\" a
    regsub -all {[$]} $a \\\$ a
    eval evalEmbeddedCommands2 \"$a\"
}

proc evalEmbeddedCommands2 {a} {return $a}

# get_value
#    Returns value of an item that may be a number or a variable
# Argument
#    val: Either a number or a UI variable

proc get_value {val} {

    if {[regexp {[a-zA-Z]} $val ]} {
	return [get_variable_value $val]
    } else {
	return $val
    }
}

# remove_end_spaces
#   Removes spaces from start and end of string.

proc remove_end_spaces {string} {
    return [remove_trailing_spaces [remove_leading_spaces $string]]
}

# remove_trailing_spaces
#   Removes any spaces from end of string

proc remove_trailing_spaces {string} {
    for {set i [expr [string length $string]-1]} {([string index $string $i]==" ")&&($i>=0)} {incr i -1} {}
    return [string range $string 0 $i]
}

# remove_leading_spaces
#   Removes any spaces from beginning of string

proc remove_leading_spaces {string} {
    for {set i 0} {([string index $string $i]==" ")&&($i<=[expr [string length $string]-1])} {incr i} {}
    return [string range $string $i end]
}


# max
#   returns larger of two arguments

proc max {v1 v2} {
    if {$v1>$v2} {return $v1} else {return $v2}
}

# min
#   returns smaller of two arguments

proc min {v1 v2} {
    if {$v1<$v2} {return $v1} else {return $v2}
}

# int
#  Round down to nearest integer

proc int {v} {
    if {[regexp {[.]} $v] == 0} {return $v}
    return [expr [lindex [split $v .] 0]]
}
