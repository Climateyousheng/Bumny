# table_commands.tcl
#   These procedures deal with the creation of GHUI tables.
#   They are called by the script generated by the
#   GHUI when it parses a .pan file.

# Global variables
# currentTableName : Name of table currently in the process of being built
# Table : Array containing properties of table
#    Elements of Table array:
#  Each table named "n" has a number of array element of the form
#    $Table($n,<element>) 
#  where <element> can be one of the following
#  LengthType : VARLEN if controlled by a GHUI variable or FIXLEN
#               if table is fixed length
#  MaxLength, MinLength: Size limits set by GHUI
#  MaxDisplay : Number of lines to display
#  nRows : Current table length
#  nCols : Number of columns (excluding number column)
#  Numbered : Logical : Does table have a number column
#  Title : Main title
#  Super : List of super headings
#  nSuper : Number of superheadings
#  lastCol : The rightmost column which corresponding super heading covers
#  Heading : List of titles of columns
#  Width : List of requested column widths
#  State : A list of normal states, one per column:
#    1 = Normal entry box
#    2 = Non editable box which can take focus and binding
#    3 = Non editable box for description only
#  Indexed : Logical - Is the table indexed ?
#  MasterIndex : Master index of an indexed table
#  Index,$var : Subindex of a column relating to a variable


# tableStart
#   Sets up title and other parameters in a global array. Also
#   sets some default parameters.
# Arguments
#   These are the args given to the .table construct in the .pan file.
#   Those referred to as junk are unused args.
#  n : Table name
#  title : Main title of table
#  lengthType : Number of rows: Either a GHUI variable name or a number
#  maxDisplay : Maximum number of rows to display
#  sortOrder  : Affects the way columns are sorted

proc tableStart {n title junk junk lengthType maxDisplay sortOrder} {
    global Table
    global currentTableName
    global win
    global cases case_no in_case in_invis in_colour

    if {[array names Table $n,*] != ""} {
	error "Table $n already exists [array names Table $n,*]"
    }

    set Table(currentTable,$n) 1

    if {[regexp {[a-zA-Z]} $lengthType ]} {
	set Table($n,LengthType) VARLEN
	set Table($n,LinkVar) [lindex [split $lengthType {[]}] 0]
	set Table($n,LengthAdjustment) [lindex [split $lengthType {[]}] 1]
	set len1 [get_variable_value $Table($n,LinkVar)]
	if {$len1 == ""} {set len1 0}
	set length [expr $len1 $Table($n,LengthAdjustment)]
	lappend Table($Table($n,LinkVar)) $n
	set Table($n,MaxLength) 200
	set Table($n,MinLength) 0
    } else {
	set length $lengthType
	set Table($n,LengthType) FIXLEN
	set Table($n,MaxLength) $length
	set Table($n,MinLength) $length
    }

    # Size of display area
    set Table($n,MaxDisplay) [get_value $maxDisplay]

    set Table($n,nRows) $length
    set Table($n,Title) $title
    set Table($n,SortOrder) $sortOrder
    set Table($n,Indexed) 0
    

    # Initialise a few things
    set Table($n,VarList) ""
    set Table($n,InSuper) 0
    set Table($n,nSuper) 0
    set Table($n,nCols) 0
    set Table($n,Numbered) 0


    set currentTableName $n

    # Add table to list of cases for this window
    if {$in_case || $in_invis || $in_colour} {
	lappend cases($case_no) [list table $n]
    }	
}

# tableSuper
#   Initialise a super heading - a heading which covers 1 or more
#   columns
# Arguments
#   heading: Text for heading
# Comments
#   This heading will head the next and subsequent columns declared
#   until tableSuperend is called.

proc tableSuper {heading} {
    global Table
    global currentTableName

    set n $currentTableName

    if {$Table($n,InSuper) == 1} {
	error "Super headings cannot be nested in table $currentTableName"
    }

    set Table($n,InSuper) 1
    set nCols $Table($n,nCols)
    if {$Table($n,nSuper) == 0} {
	# First super heading
	if {$nCols != 0} {
	    # Not first column so set up a blank superheading
	    # to cover preceding columns
	    set Table($n,Super) ""
	    set Table($n,lastCol) [expr $nCols - 1 + $Table($n,Numbered)]
	    incr Table($n,nSuper)
	}
    }
    incr Table($n,nSuper)
    lappend Table($n,Super) $heading
    #puts "Super $Table($n,Super)"
}

# tableSuperend
#   Terminates the range of the current super heading at the current
#   column

proc tableSuperend {} {
    global Table
    global currentTableName

    set n $currentTableName

    set nCols $Table($n,nCols)
    lappend Table($n,lastCol) [expr $nCols - 1 + $Table($n,Numbered)]
    set Table($n,InSuper) 0
    #puts "Superend $Table($n,lastCol)"
}

# tableElement
#   Adds a column to a table
# Arguments
#   heading : title of column
#   variable : GHUI variable linked to column
#   junk : unused
#   width : requested width in entrybox character units - can be integer
#           or application variable name
#   writability : Determines State of column
#      in : Normal, editable entry box
#      out : Non-editable descriptive column

proc tableElement {heading variable junk width writability} {
    global Table
    global currentTableName
    global in_case in_invis in_colour cases case_no

    set n $currentTableName

    # Help text used in error dialog boxes
    set_help_text $variable $heading


    set nCols $Table($n,nCols)
    incr Table($n,nCols)

    set Table($n,$nCols) $variable

    # Before setting values in column, need to see if this table
    # is indexed as this may modify values

    # If table is indexed, values might need reordering, otherwise
    # tableCheckIndexing just returns the variable's current value
    lappend Table($n,Values) [tableCheckIndexing $n $nCols]

    if {$writability == "in"} {
	set Table($n,State,$nCols) 1
    } elseif {$writability == "out"} {
	set Table($n,State,$nCols) 3
    } else {
	set Table($n,State,$nCols) 2
	set Table($n,BindCommand,$nCols) $writability
    }
    lappend Table($n,Width) [get_value $width]
    lappend Table($n,Heading) $heading

    set varInfo [get_variable_info $variable]
    # Get type of variable and set i, r or c for real, int, char
    set type [lindex $varInfo 3]
    set i [lsearch [list INT REAL STRING] $type]
    if {$i < 0} {
	lappend Table($n,DataType) "c"
    } else {
	lappend Table($n,DataType) [lindex [list "i" "r" "c"] $i]
    }
    # Set maximum length (applies to strings)
    lappend Table($n,StringLength) [lindex $varInfo 4]
    

    if {$in_case || $in_invis || $in_colour} {
	lappend cases($case_no) [list column "$n $nCols"]
    }	
}

# tableCheckIndexing
#   For indexed tables, variables may need to be reordered if the
#   master index has changed since job last opened.
# Arguments
#   n : table id
#   colNo : Column number
# Result
#   Returns list value to be inserted in the table column
# Method
#   If table is not indexed, just return the value of the variable.
#   If table is indexed, check that the master index and the sub-index
#   for this column match. If they do then indexing is up to date; just
#   return value.
#     If indexes do not match it implies that the order of the master 
#   index has changed or that rows have been added or removed. Sort
#   the column to match, and also reset the sub-index to be the same
#   as the master. 

proc tableCheckIndexing {n colNo} {
    global Table

    # This is the variable...
    set variable $Table($n,$colNo)
    # ...now we need to find out whether its values have been reorded by
    # a change in index.

    if $Table($n,Indexed) {
	set MasterIndex $Table($n,MasterIndex)
	set subIndex $Table($n,Index,$variable)
	set vals [get_variable_array $variable]
	set indexVals [get_variable_array $subIndex]
	
	if {$subIndex == $MasterIndex} {
	    # Index same as master index - this is not a user input variable
	    set data $vals
	} else {
	    set sortedVals {}
	    set k 0
	    set masterVals [get_variable_array $MasterIndex]
	    for {set i 0} {$i < [llength $masterVals]} {incr i} {
		set found 0
		for {set j 0} {$j < [llength $indexVals] && $found == 0} {incr j} {
		    incr k
		    if {[lindex $indexVals $j] == [lindex $masterVals $i]} {
			lappend sortedVals [lindex $vals $j]
			set found 1
		    }
		}
		if {$found==0} {
		    # Row $i of master index was not found in the sub-index variable
		    # so this row must be new since last version - put a gap into the
		    # table variable to match it.
		    lappend sortedVals {}
		}
	    }
	    set data $sortedVals
	}
    } else {
	# Table not indexed - so values just the same
	set data [get_variable_array $variable]
    }

    return $data
}
		

# tableElementautonum
#   Requests an enumerated column be added to a table. 
#   Must be the first column of a table.

proc tableElementautonum {heading startNum junk width} {
    global Table
    global currentTableName
   

    set n $currentTableName
    if {$Table($n,nCols) != 0} {

	# Need this rule because we need to know how to index
	# superheadings 

	error "table $n: elementautonum should precede all other columns"
    }

    
    set Table($n,Numbered) 1
    set Table($n,StartNumber) $startNum
    lappend Table($n,Heading) $heading
    lappend Table($n,Width) [get_value $width]
}

# tableIndexed
#   Row order will be controlled by indexes in order to enable
#   reordering of rows from release to release. This proc sets
#   up Table array with requirements to be dealt with when table
#   is created.
# Arguments
#   indexedVar : Input variable
#   index : Index variable that may result in the reordering of
#           the values in indexedVar

proc tableIndexed {indexedVar index} {
    global Table
    global currentTableName
   
    set n $currentTableName
 
    if !$Table($n,Indexed) {
        # puts "first index is master index= $index"
	set Table($n,MasterIndex) $index
        set Table($n,Indexes) {}
        set Table($n,IndexedVariable) {}
    }
    set Table($n,Index,$indexedVar) $index
    set Table($n,Indexed) 1
}


# tableEnd
#   Called when table fully set up. Backs up variables and calls
#   routine to create the table widgets.

proc tableEnd {} {
    global Table
    global currentTableName

    set n $currentTableName

    if $Table($n,Indexed) {
	# Table is indexed, make sure that all the sub-indexes
	# have been reset to the new index
	set nCols $Table($n,nCols)
	set masterIndex $Table($n,MasterIndex)
	set masterVals [get_variable_array $masterIndex]
	set list $masterIndex
	for {set i 0} {$i < $nCols} {incr i} {
	    set variable $Table($n,$i)
	    set subIndex $Table($n,Index,$variable)
	    if {[lsearch $list $subIndex] == -1} {
		lappend list $subIndex
		
		# Back up in case abandon pressed by user
		backupTableVar $subIndex
		set_variable_array $subIndex $masterVals
	    }
	}
    }    
    
    GHUIcreateTable $n
}

